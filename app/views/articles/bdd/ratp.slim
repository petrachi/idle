p Bonjour ami lecteur. Dis-moi, l'algorithme de <i>Djikstra</i> ça te parle ? Non ? Tant mieux ! Bah oui, puisque c'est de ça qu'on va parler aujourd'hui !

h3 La Carte

p Forcément, on te dit "algorithme", et toi tu te demandes à quoi il sert cet algorithme. Tout simplement à trouver le plus court chemin entre deux points sur une carte. Comme l'itinéraire sur un GPS quoi !

p Mais avant de se lancer dans des calculs compliqués, il va d'abord falloir établir la base #{":"} la carte. Pour ça, on va utiliser un graphe, une collection de points reliés (ou pas) entre eux, par exemple #{":"}

svg id='graph-simple' viewBox='0 50 400 140'
  line x1='100' x2='80' y1='160' y2='80'
  line x1='100' x2='160' y1='160' y2='100'
  line x1='160' x2='80' y1='100' y2='80'
  line x1='160' x2='250' y1='100' y2='80'

  circle r='10' cx='100' cy='160'
  circle r='10' cx='80' cy='80'
  circle r='10' cx='160' cy='100'
  circle r='10' cx='250' cy='80'

  text x='95.5' y='165.5' A
  text x='75.5' y='85.5' B
  text x='154' y='105.5' C
  text x='245.5' y='85.5' D

p En mathématiques, en informatique, et même en général, les graphes ont tout un tas d'usages. Par exemple la liste de nos amis facebook est représentée sous forme de graphe, ou la liste des entrerpises et de leurs filliales impliquées dans le fameux scandale des <i>Panama Papers</i>, ça aussi c'est un graphe.

p Nous, comme exemple, on va choisir quelque chose de plus "lisse", le réseau du métro parisien. Chaque point du graphe représentera une station de métro, et les liens entre les points représenterons les différentes lignes.

p À partir de cette base, on va pouvoir ajouter plus d'informations sur les éléments de notre graphe #{":"} la position géographique de chaque point (pour calculer la distance entre deux points), et la direction des liens entre les points (parce qu'il y a quelques lignes bizzaroïdes à sens uniques, hé oui).

svg id='graph-w/data' viewBox='0 50 400 140'
  marker id='markerArrow' markerWidth='8' markerHeight='8' refX='4' refY='4' orient='auto'
    path d='M 0 0 L 6 4 L 0 8 Z' fill='#111'

  line x1='100' x2='83' y1='160' y2='92' marker-end='url(#markerArrow)'
  line x1='100' x2='151' y1='160' y2='108' marker-end='url(#markerArrow)'
  line x1='160' x2='92' y1='100' y2='82' marker-end='url(#markerArrow)'
  line x1='160' x2='238' y1='95' y2='78' marker-end='url(#markerArrow)'
  line x1='250' x2='172' y1='85' y2='102' marker-end='url(#markerArrow)'

  circle r='10' cx='100' cy='160'
  circle r='10' cx='80' cy='80'
  circle r='10' cx='160' cy='100'
  circle r='10' cx='250' cy='80'

  text x='95.5' y='165.5' A
  text x='75.5' y='85.5' B
  text x='154' y='105.5' C
  text x='245.5' y='85.5' D

  g id='coordinates'
    text x='115.5' y='157' x: 100
    text x='115.5' y='165.5' y: 160
    text x='93.5' y='68.5' x: 80
    text x='93.5' y='77' y: 80
    text x='165.5' y='117' x: 160
    text x='165.5' y='125.5' y: 100
    text x='265.5' y='77' x: 250
    text x='265.5' y='85.5' y: 80

p Bon, et tout ça converti en code, et bien c'est finalement assez simple #{":"} ça tiens en trois #{ coderay "class", inline: true }es !

= coderay do
  | class Graph
      attr_accessor :links, :nodes

      def initialize
        @links = []
        @nodes = []
      end

      def link node_a, node_b, **options
        links << RATP::GraphLink.new(node_a, node_b, **options)
      end
    end

= coderay do
  | class GraphNode
      attr_accessor :attributes, :links

      def initialize attrs: {}
        @attributes = attrs
        @links = []
      end
    end

= coderay do
  | class RATP::GraphLink
      attr_accessor :attributes, :dist, :node_a, :node_b

      def initialize node_a, node_b, dist:, attrs: {}
        @attributes = attrs
        @dist = dist
        @node_a = node_a
        @node_b = node_b

        node_a.links << self
      end
    end

h3 Open Data

p Bon, maintenant il ne reste plus qu'à mettre en place notre graphe du métro parisien. 302 stations, 16 lignes (en comptant les <i>bis</i>). Ça risque d'être long et pénible ! Mais heureusement, tu m'as ! Et j'ai la solution !

p Il se trouve que la RAPT (le gestionnaire du métro parisien) met à disposition sur son site internet tout un tas d'informations que nous allons pouvoir utiliser pour créer notre graphe #{":"} la liste des stations, leurs fréquentation, correspondances, etc.

p Le seul hic (parce qu'il y a un hic), c'est que l'information principale qui nous intéresse, à savoir la position géographique des station (lattitude et longitude) n'est pas lié directement aux stations de métro , mais aux différents points d'accès aux stations. Et ce qui rends le tout encore plus compliqué, c'est qu'il n'y a pas de lien entre les points d'accès et les stations en elles-mêmes.

p Alors il va falloir y mettre un tout petit peu d'huile de coude tout de même, et en faisant avec une comparaison entre les noms des stations et ceux des points d'accès, on devrait arriver à quelque chose de pas trop mal. Allez, on y croit à mort, et on fait le test pour toutes les stations de la ligne <span class='l1'>1</span> #{":"}

svg id='ratp-l1' viewBox='0 0 1000 1000'
  defs
    g id='ratp-background'
      path d='M 334.6354166666667, 182.40620957309184 L 739.5833333333334, 184.99353169469597 L 897.1354166666666, 342.82018111254854 L 897.1354166666666, 485.12289780077623 L 880.2083333333334, 503.2341526520052 L 881.5104166666666, 673.9974126778784 L 723.9583333333334, 829.2367399741267 L 178.38541666666666, 833.117723156533 L 79.42708333333333, 737.3868046571798 L 82.03125, 450.1940491591203 Z' fill='#ffffff'

      path d='M 411.4583333333333, 5.17464424320828 L 427.0833333333333, 3.8809831824062098 L 468.75, 43.98447606727038 L 471.3541666666667, 82.79430789133248 L 450.5208333333333, 104.78654592496765 L 332.03125, 108.66752910737387 L 29.947916666666668, 406.20957309184996 L 29.947916666666668, 815.006468305304 L 82.03125, 864.1655886157827 L 118.48958333333333, 862.8719275549805 L 162.76041666666666, 824.0620957309185 L 164.0625, 598.9650711513583 L 230.46875, 534.2820181112548 L 544.2708333333334, 535.575679172057 L 610.6770833333334, 596.3777490297541 L 609.375, 618.3699870633894 L 792.96875, 795.601552393273 L 997.3958333333334, 798.188874514877 L 998.6979166666666, 813.7128072445018 L 802.0833333333334, 812.4191461836999 L 802.0833333333334, 990.9443725743855 L 785.15625, 990.9443725743855 L 783.8541666666666, 813.7128072445018 L 555.9895833333334, 586.0284605433377 L 467.4479166666667, 580.8538163001293 L 429.6875, 544.6313065976715 L 236.97916666666666, 547.2186287192756 L 179.6875, 602.8460543337646 L 175.78125, 831.8240620957309 L 123.69791666666667, 882.2768434670116 L 79.42708333333333, 883.5705045278137 L 16.927083333333332, 824.0620957309185 L 15.625, 402.3285899094437 L 328.125, 93.14359637774903 L 441.40625, 91.84993531694697 L 457.03125, 76.32600258732212 L 455.7291666666667, 51.746442432082794 Z' fill='#aae1fa'

      path d='M 561.1979166666666, 562.7425614489003 L 597.65625, 595.0840879689522 L 597.65625, 610.608020698577 L 559.8958333333334, 578.2664941785252 Z' fill='#ffffff'

      path d='M 447.9166666666667, 545.9249676584734 L 550.78125, 548.5122897800776 L 549.4791666666666, 569.2108667529108 L 472.65625, 571.7981888745148 Z' fill='#ffffff'

  use xlink:href='#ratp-background'

  = RATP.graph_to_svg(RATP::OpenDataPreprocessor::L1_GRAPH).html_safe

p Aïe ... Je crois qu'on y a un peu trop cru. (Pour tous ceux qui ne connaissent pas par coeur les lignes de métro parisiennes, la ligne <span class='l1'>1</span> traverse la ville sur un axe presque droit est - ouest.) Peu importe, l'erreur est le meilleur maître !

h3 SVG Interactif

p Retour à la case départ et à la solution bête et méchante #{":"} on pose une carte officielle du métro parisien, et à l'aide d'un petit bout de javascript, on note à la main la position de chaque station. D'ailleurs si tu veux m'aider pour ce fastidieux travail, je t'ai fait une petite carte interactive pour que tu puisse participer (lis la notice avec attention avant utilisation) #{":"}

div class='fluid'
  div id='click-container'
    svg id='click-map' viewBox='0 0 1000 1000'

  svg id='click-result' viewBox='0 0 1000 1000'
    use xlink:href='#ratp-background'

  javascript:
    (function() {
      scroll = document.querySelector('.content')
      elt = document.querySelector('div#click-container')
      svg = elt.querySelector('svg#click-map')
      target = document.querySelector('svg#click-result')

      elt.addEventListener('click', function(e){
        var pos = {
          x: e.pageX - e.currentTarget.offsetLeft,
          y: e.pageY - e.currentTarget.offsetTop + scroll.scrollTop
        }

        var size = {
          x: parseInt(window.getComputedStyle(elt).width, 10),
          y: parseInt(window.getComputedStyle(elt).height, 10),
        }

        var c = {
          x: pos.x / size.x * 1000,
          y: pos.y / size.y * 1000
        }

        last = target.querySelector('circle:last-of-type')
        if(last){
          var line = document.createElementNS('http://www.w3.org/2000/svg', 'line')
          line.setAttribute('x1', last.getAttribute("cx"))
          line.setAttribute('x2', c.x)
          line.setAttribute('y1', last.getAttribute("cy"))
          line.setAttribute('y2', c.y)
          target.appendChild(line)
        }

        var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
        circle.setAttribute('cx', c.x)
        circle.setAttribute('cy', c.y)
        circle.setAttribute('r', 5)
        target.appendChild(circle)

        var text = document.createElementNS('http://www.w3.org/2000/svg', 'text')
        text.setAttribute('x', c.x + 10)
        text.setAttribute('y', c.y)
        text.innerHTML = "x: " + Math.round(c.x, -1)
        target.appendChild(text)

        var text = document.createElementNS('http://www.w3.org/2000/svg', 'text')
        text.setAttribute('x', c.x + 10)
        text.setAttribute('y', c.y + 15)
        text.innerHTML = "y: " + Math.round(c.y, -1)
        target.appendChild(text)
      });
    }).call(this)

p class="align-center" <i><small>(essaye de relier toutes les stations de la ligne 1 (en jaune) en cliquant sur chaque station<br/> de la ligne sur la carte officielle à gauche, et vois le résultat apparaitre au fur et à mesure sur<br/> le dessin à droite)</small></i>

h3 Djikstra

p Bien, le temps que tu finisse notre graphe du métro parisien, je vais en profiter pour t'expliquer (enfin) le fonctionnement de l'algorithme de Djikstra.

p Le principe est de parcourir petit à petit tous les points (les noeuds), du graphe en enregistrant à chaque étape la distance parcourue (qu'on appellera le <i>score</i> d'un noeud). Quand arrive finalement au noeud d'arrivée, l'algorithme peut remonter la trace de tous les noeuds intermédiaires parcourus jusqu'au point de départ, en choississant à chaque fois les noeuds avec le score le plus faible.

p Prenons un exemple #{":"}

svg id='graph-example' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80'
  line x1='100' x2='160' y1='160' y2='100'
  line x1='160' x2='80' y1='100' y2='80'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='160' y1='80' y2='40'
  line x1='250' x2='160' y1='80' y2='40'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80'
  circle r='10' cx='160' cy='100'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='160' cy='40'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' B
  text x='154' y='105.5' C
  text x='245.5' y='85.5' class='red' D
  text x='155.5' y='45.5' E
  text x='205.5' y='135.5' F

  g class='dist'
    text x='80' y='120' 1
    text x='135' y='135' 4
    text x='120' y='85' 2
    text x='200' y='85' 2
    text x='120' y='55' 1
    text x='205' y='55' 4
    text x='175' y='125' 4
    text x='230' y='115' 3

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

p Tu l'auras compris cher lecteur, le but ici est de trouver chemin le plus court entre le point #{ coderay 'A', inline: true } et le point #{ coderay 'D', inline: true }. Tu peux voir aussi que j'ai ajouté les distances directement sur les liens, les arcs du graphe (et qui ici ne représentent pas les distances géographiques entre les noeuds).

p Au début, chaque noeud à un score infini, à l'exception du noeud de départ qui lui à un score nul.

svg id='graph-example-dist' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80'
  line x1='100' x2='160' y1='160' y2='100'
  line x1='160' x2='80' y1='100' y2='80'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='160' y1='80' y2='40'
  line x1='250' x2='160' y1='80' y2='40'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80'
  circle r='10' cx='160' cy='100'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='160' cy='40'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' B
  text x='154' y='105.5' C
  text x='245.5' y='85.5' class='red' D
  text x='155.5' y='45.5' E
  text x='205.5' y='135.5' F

  g class='dist'
    text x='80' y='120' 1
    text x='135' y='135' 4
    text x='120' y='85' 2
    text x='200' y='85' 2
    text x='120' y='55' 1
    text x='205' y='55' 4
    text x='175' y='125' 4
    text x='230' y='115' 3

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='82' y='68' ∞
    text x='162' y='88' ∞
    text x='252' y='68' ∞
    text x='162' y='28' ∞
    text x='212' y='118' ∞

p La première étape est de calculer le score de tous les noeuds directement liés au noeud #{ coderay 'A', inline: true } #{":"}

svg id='graph-example-node-a' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80' class='blue'
  line x1='100' x2='160' y1='160' y2='100' class='blue'
  line x1='160' x2='80' y1='100' y2='80'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='160' y1='80' y2='40'
  line x1='250' x2='160' y1='80' y2='40'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='green'
  circle r='10' cx='80' cy='80' class='blue'
  circle r='10' cx='160' cy='100' class='blue'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='160' cy='40'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' class='blue' B
  text x='154' y='105.5' class='blue' C
  text x='245.5' y='85.5' class='red' D
  text x='155.5' y='45.5' E
  text x='205.5' y='135.5' F

  g class='dist'
    text x='80' y='120' 1
    text x='135' y='135' 4
    text x='120' y='85' 2
    text x='200' y='85' 2
    text x='120' y='55' 1
    text x='205' y='55' 4
    text x='175' y='125' 4
    text x='230' y='115' 3

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='55' y='64' class='blue' 0 + 1 #{"="} 1 via A
    text x='135' y='88' class='blue' 0 + 4 #{"="} 4 via A
    text x='252' y='68' ∞
    text x='162' y='28' ∞
    text x='212' y='118' ∞

p Ensuite, nous allons ajouter les deux noeuds pour lesquels nous venons de calculer le score dans une liste "à explorer". Puis il ne reste qu'à recommencer la première étape avec le noeud dans la liste qui possède le plus petit score, ici, le noeud #{ coderay 'B', inline: true } #{":"}

svg id='graph-example-node-b' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80' class='blue'
  line x1='100' x2='160' y1='160' y2='100' class='blue'
  line x1='160' x2='80' y1='100' y2='80' class='blue'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='160' y1='80' y2='40' class='blue'
  line x1='250' x2='160' y1='80' y2='40'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80' class='green'
  circle r='10' cx='160' cy='100' class='blue'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='160' cy='40' class='blue'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' class='blue' B
  text x='154' y='105.5' class='blue' C
  text x='245.5' y='85.5' class='red' D
  text x='155.5' y='45.5' class='blue' E
  text x='205.5' y='135.5' F

  g class='dist'
    text x='80' y='120' 1
    text x='135' y='135' 4
    text x='120' y='85' 2
    text x='200' y='85' 2
    text x='120' y='55' 1
    text x='205' y='55' 4
    text x='175' y='125' 4
    text x='230' y='115' 3

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='68' y='64' class='blue' 1 via A
    text x='148' y='78' class='blue stroke' 4 via A
    text x='135' y='88' class='blue' 1 + 2 #{"="} 3 via B
    text x='252' y='68' ∞
    text x='135' y='26' class='blue' 1 + 1 #{"="} 2 via B
    text x='212' y='118' ∞

  g class='to-expand'
    text x='335' y='26' À explorer
    circle r='10' cx='355' cy='40' class='green'
    text x='350.5' y='45.5' B
    circle r='10' cx='355' cy='65'
    text x='349' y='70.5' C

p Tu as vu ami lecteur ? Le score du noeud #{ coderay 'C', inline: true } est passé de <i>4</i> à <i>3</i>. C'est parce qu'il est en fait plus court de passer par le noeud #{ coderay 'B', inline: true } pour rejoindre le noeud #{ coderay 'C', inline: true }, que d'y aller directement à partir de #{ coderay 'A', inline: true }.

p Maintenant, c'est le noeud #{ coderay 'E', inline: true }, qui à été ajouté à la liste "à explorer" lors de l'étape précédente et qui possède le plus petit score dans cette liste, que nous allons explorer.

svg id='graph-example-node-e' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80' class='blue'
  line x1='100' x2='160' y1='160' y2='100' class='blue'
  line x1='160' x2='80' y1='100' y2='80' class='blue'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='160' y1='80' y2='40' class='blue'
  line x1='250' x2='160' y1='80' y2='40' class='blue'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80' class='blue'
  circle r='10' cx='160' cy='100' class='blue'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='160' cy='40' class='green'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' class='blue' B
  text x='154' y='105.5' class='blue' C
  text x='245.5' y='85.5' class='red' D
  text x='155.5' y='45.5' class='blue' E
  text x='205.5' y='135.5' F

  g class='dist'
    text x='80' y='120' 1
    text x='135' y='135' 4
    text x='120' y='85' 2
    text x='200' y='85' 2
    text x='120' y='55' 1
    text x='205' y='55' 4
    text x='175' y='125' 4
    text x='230' y='115' 3

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='68' y='64' class='blue' 1 via A
    text x='148' y='88' class='blue' 3 via B
    text x='260' y='68' class='red' 2 + 4 #{"="} 6 via E
    text x='148' y='28' class='blue' 2 via B
    text x='212' y='118' ∞

  g class='to-expand'
    text x='335' y='26' À explorer
    circle r='10' cx='355' cy='40' class='green'
    text x='350.5' y='45.5' E
    circle r='10' cx='355' cy='65'
    text x='349' y='70.5' C

p Bien, nous avons maintenant le score du noeud #{ coderay 'D', inline: true }, notre arrivée ! Mais attention, ça n'est pas encore terminé. Et bien oui, il n'est pas impossible que l'on trouve un chemin encore plus court pour arriver au noeud #{ coderay 'D', inline: true }, comme c'est arrivé tout à l'heure pour le noeud #{ coderay 'C', inline: true }. L'algorithme sera terminé lorsque ça sera au tour du noeud #{ coderay 'D', inline: true } d'être exploré.

p Pour l'instant, on va continuer comme avant à dépiler notre liste des noeuds à explorer, et maintenant, c'est au tour du noeud #{ coderay 'C', inline: true } #{":"}

svg id='graph-example-node-c' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80' class='blue'
  line x1='100' x2='160' y1='160' y2='100' class='blue'
  line x1='160' x2='80' y1='100' y2='80' class='blue'
  line x1='160' x2='250' y1='100' y2='80' class='blue'
  line x1='80' x2='160' y1='80' y2='40' class='blue'
  line x1='250' x2='160' y1='80' y2='40' class='blue'
  line x1='160' x2='210' y1='100' y2='130' class='blue'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80' class='blue'
  circle r='10' cx='160' cy='100' class='green'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='160' cy='40' class='blue'
  circle r='10' cx='210' cy='130' class='blue'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' class='blue' B
  text x='154' y='105.5' class='blue' C
  text x='245.5' y='85.5' class='red' D
  text x='155.5' y='45.5' class='blue' E
  text x='205.5' y='135.5' class='blue' F

  g class='dist'
    text x='80' y='120' 1
    text x='135' y='135' 4
    text x='120' y='85' 2
    text x='200' y='85' 2
    text x='120' y='55' 1
    text x='205' y='55' 4
    text x='175' y='125' 4
    text x='230' y='115' 3

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='68' y='64' class='blue' 1 via A
    text x='148' y='88' class='blue' 3 via B
    text x='260' y='58' class='red stroke' 6 via E
    text x='260' y='68' class='red' 3 + 2 #{"="} 5 via C
    text x='148' y='28' class='blue' 2 via B
    text x='225' y='132.5' class='blue' 3 + 4 #{"="} 7 via C

  g class='to-expand'
    text x='335' y='26' À explorer
    circle r='10' cx='355' cy='40' class='green'
    text x='349' y='45.5' C
    circle r='10' cx='355' cy='65'
    text x='350.5' y='70.5' D

p Et regarde ami lecteur, nous avons bien fait d'attendre puisque le score du noeud #{ coderay 'D', inline: true } vient de diminuer (comme cet exemple est bien fait) !

p Il y a maintenant dans la liste des noeuds à explorer les noeuds #{ coderay 'D', inline: true } et #{ coderay 'F', inline: true }, et comme c'est le noeud #{ coderay 'D', inline: true } qui a le plus petit score, c'est donc la fin de la phase d'exploration algorithme !

p La dernière étape de l'algorithme est de parcourir à l'inverse la liste des noeuds que nous avons parcourus afin de récupérer le chemin le plus court #{":"} #{ coderay 'A -> B -> C -> D', inline: true }. C'est simple comme réciter l'alaphabet !

h3 Pathfinder

p Maintenant que tout est clair, on va pouvoir écrire le code correspondant et laisser l'ordinateur faire tous les calculs à notre place. Et zahou !

= coderay do
  | to_expand = Hash.new{ |hash, key| hash[key] = {dist: Float::INFINITY, via: nil}}
    to_expand[from] = {dist: 0, via: nil}

    expanded = {}

p Pour commencer, on va créer un hash #{ coderay 'to_expand', inline: true } qui nous servira à sauvegarder la liste de tous les noeuds à explorer. Pour l'instant il n'y a qu'une seule valeur dans le hash, le noeud de départ.

p Nous allons aussi créer aussi un hash #{ coderay 'expanded', inline: true } dans lequel on mettra les noeuds explorés.

p Ensuite, nous allons créer une boucle qui servira à explorer les diférents noeuds #{":"}

= coderay do
  | loop do
      node, values = to_expand.min{ |(_,a), (_,b)| a[:dist] <=> b[:dist] }

      if node == to
        expanded[node] = to_expand.delete(node)
        break
      end

      node.links(exclude_nodes: expanded.keys).each do |link|
        dist = values[:dist] + link.dist

        if dist < to_expand[link.node_b][:dist]
          to_expand[link.node_b][:dist] = dist
          to_expand[link.node_b][:via] = node
        end
      end

      expanded[node] = to_expand.delete(node)
    end

p On commence par sélectionner le noeud à explorer dans le hash #{ coderay 'to_expand', inline: true }.

= coderay do
  | node, values = to_expand.min{ |(_,a), (_,b)| a[:dist] <=> b[:dist] }

p Puis nous allons mettre à jour les scores des noeuds directements liés au noeud en cours d'exploration (à l'exception des noeuds déjà explorés).

= coderay do
  | node.links(exclude_nodes: expanded.keys).each do |link|
      dist = values[:dist] + link.dist

      if dist < to_expand[link.node_b][:dist]
        to_expand[link.node_b][:dist] = dist
        to_expand[link.node_b][:via] = node
      end
    end

p Tu peux remarquer, cher lecteur, que grâce à la veleur par défault que nous avons mise sur le hash #{ coderay 'to_expand', inline: true }, le noeud comparé est ajouté au hash lors de l'évaluation de #{ coderay 'dist < to_expand[link.node_b][:dist]', inline: true }.

p Finalement, nous pouvons transférer le noeud exploré vers le hash #{ coderay 'expanded', inline: true }.

= coderay do
  | expanded[node] = to_expand.delete(node)

p La boucle se termine lorsque le noeud à explorer correspond au noeud d'arrivée.

= coderay do
  | if node == to
      expanded[node] = to_expand.delete(node)
      break
    end

p Enfin, il reste à remonter la liste des noeuds explorés pour retrouver le chemin le plus court #{":"}

= coderay do
  | path = [to]

    loop do
      break unless expanded[path.first][:via]
      path.insert(0, expanded[path.first][:via])
    end

    path.map{ |e| {node: e}.merge(expanded[e]) }

p Petit à petit, nous insérons dans le tableau #{ coderay 'path', inline: true } les différents noeuds en fonctions de l'information #{ coderay ':via', inline: true } calculée lors de la phase d'exploration. Quand cette information est vide, cela veut dire que nous sommes remontés au point de départ.

p Il est temps de faire un test en conditions réelles. Si on prends la carte du métro que tu as enfin terminée et qu'on y teste un trajet que je connais bien (de <i>Mairie de Clichy</i> dans le nord jusqu'à <i>Villejuif - Léo Lagrange</i> au sud), le résultat est saisissant #{":"}

svg id='ratp-djikstra-dist' viewBox='0 0 1000 1000'
  use xlink:href='#ratp-background'
  = RATP.path_to_svg('djikstra_dist', from: 'MAIRIE DE CLICHY', to: 'VILLEJUIF-LEO LAGRANGE').html_safe

p C'est un bon début ! Cela dit, il y a au moins une chose ce que ne montre pas cette illustration #{":"} un problème dont il va falloir s'occuper avant d'aller plus loin.

h3 Level UP

p Si on affiche étape par étape les noeuds explorés par l'algorithme, le problème devient évident #{":"}

div id='demo-djikstra-step-by-step' class='triggered-animation'
  svg id='ratp-djikstra-step-by-step' viewBox='0 0 1000 1000'
    use xlink:href='#ratp-background'
    g class='start-end'
      circle cx='304.28769017980636' cy='169.871822818295' r='10'
      circle cx='614.9659863945578' cy='869.3693418760557' r='10'
      text x='317' y='162' Départ
      text x='628' y='888' Arrivée

    = RATP.path_to_svg('djikstra_step_by_step', from: 'MAIRIE DE CLICHY', to: 'VILLEJUIF-LEO LAGRANGE', text: ->(e){ e[:dist].round }).html_safe

    p class='align-center'
      span class='btn active' animation-trigger='ratp-djikstra-step-by-step' Jouer l'animation

    javascript:
      (function() {
        var elt = document.querySelector("[animation-trigger=ratp-djikstra-step-by-step]");
        var svg_elt = document.querySelector("#ratp-djikstra-step-by-step");
        var active = false;

        svg_elt.addEventListener('play-animation', async function(){
          if(!active){
            active = true;
            svg_elt.classList.remove('play');
            await sleep(100);
            svg_elt.classList.add('play');

            console.log('hum')
            await sleep(285 * 100);
            await sleep(1500);
            console.log('yop')
            elt.classList.add('active');
          }
        });

        elt.addEventListener('click', function(){
          active = false;
          elt.classList.remove('active');
          svg_elt.dispatchEvent(new CustomEvent('play-animation'));
        });
      }).call(this)

p L'algorithme à exploré presque tous les noeuds du graphe (285 sur 306 noeuds) ! Il n'a aucune notion de direction ! Pour faire une analogie limite osée, c'est comme si toi, tu regardais une carte routière de la Normandie pour chercher ta route vers Montpellier ! Ça serait plutôt ridicule, tu ne trouves pas ?

p Heureusement, j'ai une solution pour toi #{":"} A* (prononcer 'a-star', ou 'a-étoile', au choix) !

= coderay do
  | def a_star from:, to:
      to_expand = Hash.new{ |hash, key| hash[key] = {time: Float::INFINITY, dist_to: key.dist(to), via: nil, link: nil}}
      to_expand[from] = {time: 0, via: nil, link: nil}

      expanded = {}

      loop do
        node, values = to_expand.min{ |(_,a), (_,b)| a[:time] + a[:dist_to] <=> b[:time] + b[:dist_to] }

        if node == to
          expanded[node] = to_expand.delete(node)
          break
        end

        node.links(exclude_nodes: expanded.keys).each do |link|
          time = values[:time] + link.time(corres: values[:link])

          if time < to_expand[link.node_b][:time]
            to_expand[link.node_b][:time] = time
            to_expand[link.node_b][:via] = node
            to_expand[link.node_b][:link] = link
          end
        end

        expanded[node] = to_expand.delete(node)
      end

      path = [to]

      loop do
        break unless expanded[path.first][:via]
        path.insert(0, expanded[path.first][:via])
      end

      path.map{ |e| {node: e}.merge(expanded[e]) }
    end

p L'algorithme A* ressemble beaucoup à celui de Djikstra, à une différence près #{":"} dans la liste des noeuds "à explorer", plutôt que de choisir simplement le noeud avec le plus petit score, A* va également calculer pour chaque noeud sa distance géographique avec le noeud d'arrivée, et va intégrer cette distance pour la sélection du prochain noeud à explorer.

p Si nous reprenons l'exemple du début #{":"}

svg id='graph-djikstra-node-b' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80' class='blue'
  line x1='100' x2='160' y1='160' y2='100' class='blue'
  line x1='160' x2='80' y1='100' y2='80' class='blue'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='130' y1='80' y2='40' class='blue'
  line x1='250' x2='130' y1='80' y2='40'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80' class='green'
  circle r='10' cx='160' cy='100' class='blue'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='130' cy='40' class='blue'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' class='blue' B
  text x='154' y='105.5' class='blue' C
  text x='245.5' y='85.5' class='red' D
  text x='125.5' y='45.5' class='blue' E
  text x='205.5' y='135.5' F

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='68' y='64' class='blue' 1 via A
    text x='148' y='88' class='blue' 3 via B
    text x='252' y='68' ∞
    text x='118' y='26' class='blue' 2 via B
    text x='212' y='118' ∞

  g class='to-expand'
    text x='335' y='26' À explorer
    circle r='10' cx='355' cy='40'
    text x='350.5' y='45.5' E
    circle r='10' cx='355' cy='65'
    text x='349' y='70.5' C

p Nous venons d'explorer le noeud #{ coderay 'B', inline: true } et dans la liste des noeuds à explorer, nous avons le choix entre les noeuds #{ coderay 'C', inline: true } et #{ coderay 'E', inline: true }. L'algorithme de Djikstra aurait sélectionné le noeud #{ coderay 'E', inline: true }, mais en ajoutant la distance par rapport au noeud l'arrivée, alors le prochain noeud à explorer est le noeud #{ coderay 'C', inline: true }. C'est ce que fait l'algorithme A*.

svg id='graph-astar-node-b' viewBox='0 0 400 200'
  line x1='100' x2='80' y1='160' y2='80' class='blue'
  line x1='100' x2='160' y1='160' y2='100' class='blue'
  line x1='160' x2='80' y1='100' y2='80' class='blue'
  line x1='160' x2='250' y1='100' y2='80'
  line x1='80' x2='130' y1='80' y2='40' class='blue'
  line x1='250' x2='130' y1='80' y2='40'
  line x1='160' x2='210' y1='100' y2='130'
  line x1='250' x2='210' y1='80' y2='130'

  circle r='10' cx='100' cy='160' class='blue'
  circle r='10' cx='80' cy='80' class='green'
  circle r='10' cx='160' cy='100' class='blue'
  circle r='10' cx='250' cy='80' class='red'
  circle r='10' cx='130' cy='40' class='blue'
  circle r='10' cx='210' cy='130'

  text x='95.5' y='165.5' class='blue' A
  text x='75.5' y='85.5' class='blue' B
  text x='154' y='105.5' class='blue' C
  text x='245.5' y='85.5' class='red' D
  text x='125.5' y='45.5' class='blue' E
  text x='205.5' y='135.5' F

  text x='75.5' y='185.5' class='blue' Départ
  text x='265.5' y='85.5' class='red' Arrivée

  g class='node-dist'
    text x='102' y='148' class='blue' 0
    text x='68' y='44' class='blue' dist: 5
    text x='68' y='54' class='blue' score: 1 via A
    text x='68' y='64' class='blue' total: 6
    text x='148' y='68' class='blue' dist: 3
    text x='148' y='78' class='blue' score: 3 via B
    text x='148' y='88' class='blue' total: 6
    text x='252' y='48' dist: 0
    text x='252' y='58' score: ∞
    text x='252' y='68' total: ∞
    text x='118' y='6' class='blue' dist: 4,5
    text x='118' y='16' class='blue' score: 2 via B
    text x='118' y='26' class='blue' total: 6,5
    text x='212' y='98' dist: 2
    text x='212' y='108' score: ∞
    text x='212' y='118' total: ∞

  g class='to-expand'
    text x='335' y='26' À explorer
    circle r='10' cx='355' cy='40'
    text x='349' y='45.5' C
    circle r='10' cx='355' cy='65'
    text x='350.5' y='70.5' E

p Cette optimisation permet de réduire de beaucoup le nombre de noeuds explorés. En reprenant le même trajet que tout à l'heure, la différence est clairement visible #{":"}

div id='demo-astar-step-by-step' class='triggered-animation'
  svg id='ratp-astar-step-by-step' viewBox='0 0 1000 1000'
    use xlink:href='#ratp-background'
    g class='start-end'
      circle cx='304.28769017980636' cy='169.871822818295' r='10'
      circle cx='614.9659863945578' cy='869.3693418760557' r='10'
      text x='317' y='162' Départ
      text x='628' y='888' Arrivée

    = RATP.path_to_svg('astar_step_by_step', from: 'MAIRIE DE CLICHY', to: 'VILLEJUIF-LEO LAGRANGE', text: ->(e){ (e[:dist_to] + e[:dist]).round }).html_safe

    p class='align-center'
      span class='btn active' animation-trigger='ratp-astar-step-by-step' Jouer l'animation

    javascript:
      (function() {
        var elt = document.querySelector("[animation-trigger=ratp-astar-step-by-step]");
        var svg_elt = document.querySelector("#ratp-astar-step-by-step");
        var active = false;

        svg_elt.addEventListener('play-animation', async function(){
          if(!active){
            active = true;
            svg_elt.classList.remove('play');
            await sleep(100);
            svg_elt.classList.add('play');

            console.log('hum')
            await sleep(75 * 100);
            await sleep(1500);
            console.log('yop')
            elt.classList.add('active');
          }
        });

        elt.addEventListener('click', function(){
          active = false;
          elt.classList.remove('active');
          svg_elt.dispatchEvent(new CustomEvent('play-animation'));
        });
      }).call(this)

h3 Simulation

p Tu auras peut-être remarqué comme moi, ami lecteur, que si notre algorithme A* fonctionne correctement, il n'est pas tout à fait adapter au calcul du meilleur trajet de métro #{":"} le chemin calculé nous propose de prendre la ligne <span class='l13'>13</span>, changer pour la <span class='l3'>3</span>, puis prendre la ligne <span class='l7'>7</span>, pour une station seulement, monter dans la <span class='l14'>14</span> encore pour une seule station, et finalement revenir sur la ligne <span class='l7'>7</span> !


svg id='ratp-astar-dist' viewBox='0 0 1000 1000'
  use xlink:href='#ratp-background'
  = RATP.path_to_svg('astar_dist', from: 'MAIRIE DE CLICHY', to: 'VILLEJUIF-LEO LAGRANGE').html_safe

p Le truc, c'est que les temps de changements entre les lignes ne sont pas pris en compte. Ni d'ailleurs les temps de trajet entre chaque station (certaines lignes sont plus rapides que d'autres).

p Nous allons essayer de prendre ces éléments en compte en modifiant le calcul du <i>score</i> de chaque noeud. Pour cela, on va créer une nouvelle méthode #{ coderay 'time', inline: true } dans la classe #{ coderay 'GraphLink', inline: true } qui va remplacer la méthode #{ coderay 'dist', inline: true } que l'on utilisait jusqu'à présent.

= coderay do
  | class GraphLink
      def dist
        Math.sqrt((node_a.x - node_b.x)**2 + (node_a.y - node_b.y)**2)
      end

      def time corres: nil
        time = 0
        if corres && corres.line != line # changement de ligne
          time += 30 * node_a.attributes[:correspondances].size # temps de marche dans la station
          time += 240 # temps d'attente sur le quai
        end
        time += [dist, 20].min * 1.5 # accélération / décélération
        time += [dist - 20, 0].max * 1 # vitesse max 36km/h
        time *= 0.75 if line == '14' # bonus de vitesse pour la ligne 14
        time
      end
    end

p Et voilà le résultat #{":"}

svg id='ratp-astar-time' viewBox='0 0 1000 1000'
  use xlink:href='#ratp-background'
  = RATP.path_to_svg('astar_time', from: 'MAIRIE DE CLICHY', to: 'VILLEJUIF-LEO LAGRANGE').html_safe

p Désormais, l'algorithme favorise le fait de rester le plus longtemps possible sur la même ligne. Cependant, ce changement à produit des effets de bords inatendus...

p Voici le trajet retour #{":"}

svg id='ratp-astar-time-reverse' viewBox='0 0 1000 1000'
  use xlink:href='#ratp-background'
  = RATP.path_to_svg('astar_time', from: 'VILLEJUIF-LEO LAGRANGE', to: 'MAIRIE DE CLICHY').html_safe

p En toute logique, les deux trajets devrait être identiques, seulement le temps supplémentaire au moment des changements de lignes avantage ou pénalise différemment certains trajets en fonction du point de départ.

p Si on prends le trajet aller (à partir de <i>Mairie de Clichy</i>) #{":"} à partir de l'arrêt <i>Place d'Italie</i>, il n'y a plus qu'un seul chemin possible pour arriver à <i>Villejuif - Léo Lagrange</i>. Donc c'est le chemin le plus rapide jusqu'à <i>Place d'Italie</i> qui sera choisi par l'algorithme.

p Pour arriver à <i>Place d'Italie</i>, il y a deux options au score presques identiques #{":"} passer par la <span class='l13'>13</span>, puis par la <span class='l14'>14</span> et prendre la <span class='l7'>7</span> à l'arrêt <i>Pyramides</i>; soit de passer par la <span class='l13'>13</span> puis la <span class='l6'>6</span>.

p Seulement, la première option posséde deux changements, alors que la seconde n'en a qu'un, elle est avantagée par l'algorithme qui n'a pas encore pris en compte le changement de ligne de la <span class='l6'>6</span> vers la <span class='l7'>7</span> à la station <i>Place d'Italie</i>.

p C'est un problème qu'il faudrai corriger, malheureusement le temps nous manque car il est déjà l'heure de la conclusion ! Mince.

h3 Conclusion

p Alors voilà, ami lecteur, pour cette présentation illustrée des algorithmes <i>Djikstra</i> et <i>A*</i>. J'espère que, comme d'habitude, tu t'es bien amusé, et peut-être même que tu auras appris quelque chose.

p Tu peux télécharger tous les fichiers de code en cliquant sur le bouton de téléchargement ci-dessous #{":"}

p class='align-center'
  = link_to "Télécharger les fichiers", "/dl/ratp.zip", class: :btn

p Pour le reste, on se retrouve bientôt parce qu'on a encore plein de choses à se dire ! Et avant de se quitter, je te propose une toute dernière animation #{":"} il s'agit une carte interactive pour calculer ton prochain trajet de métro dans la capitale ! Super sympa !

svg id='ratp-interactive' viewBox='0 0 1000 1000'
  use xlink:href='#ratp-background'
  = RATP.graph_to_svg(RATP::OpenDataPreprocessor::GRAPH).html_safe
  g class='start-end'
    circle cx='-100' cy='-100' r='10'
    circle cx='-100' cy='-100' r='10'
    text x='-100' y='-100' Départ
    text x='-100' y='-100' Arrivée

javascript:
  (function() {
    var svg_elt = document.querySelector("#ratp-interactive");

    var start_circle = svg_elt.querySelector("g.start-end circle:first-of-type");
    var start_text = svg_elt.querySelector("g.start-end text:first-of-type");
    var end_circle = svg_elt.querySelector("g.start-end circle:last-of-type");
    var end_text = svg_elt.querySelector("g.start-end text:last-of-type");

    var circles = svg_elt.querySelectorAll(':scope > circle');

    start_circle.addEventListener('click', function(){
      var from_circle = svg_elt.querySelector("circle.from");

      if(from_circle){
        svg_elt.classList.remove('active');
        from_circle.classList.remove('from');
        start_circle.setAttribute('cx', -100);
        start_circle.setAttribute('cy', -100);
        start_text.setAttribute('x', -100);
        start_text.setAttribute('y', -100);
      }

      var path = svg_elt.querySelectorAll('.path');
      if(path) Array.prototype.forEach.call(path, function(e){ e.classList.remove('path') });
    });

    end_circle.addEventListener('click', function(){
      var to_circle = svg_elt.querySelector("circle.to");

      if(to_circle){
        svg_elt.classList.remove('active');
        to_circle.classList.remove('to');
        end_circle.setAttribute('cx', -100);
        end_circle.setAttribute('cy', -100);
        end_text.setAttribute('x', -100);
        end_text.setAttribute('y', -100);
      }

      var path = svg_elt.querySelectorAll('.path');
      if(path) Array.prototype.forEach.call(path, function(e){ e.classList.remove('path') });
    });

    Array.prototype.forEach.call(circles, function(circle){
      circle.addEventListener('click', function(){
        var from_circle = svg_elt.querySelector("circle.from");
        var to_circle = svg_elt.querySelector("circle.to");

        if(!from_circle){
          circle.classList.add('from');
          start_circle.setAttribute('cx', circle.getAttribute('cx'));
          start_circle.setAttribute('cy', circle.getAttribute('cy'));
          start_text.setAttribute('x', circle.getAttribute('cx') - 25);
          start_text.setAttribute('y', circle.getAttribute('cy') - 15);
        }else{
          if(to_circle) to_circle.classList.remove('to');

          circle.classList.add('to');
          end_circle.setAttribute('cx', circle.getAttribute('cx'));
          end_circle.setAttribute('cy', circle.getAttribute('cy'));
          end_text.setAttribute('x', circle.getAttribute('cx') - 25);
          end_text.setAttribute('y', circle.getAttribute('cy') - -25);
        }

        var from_circle = svg_elt.querySelector("circle.from");
        var to_circle = svg_elt.querySelector("circle.to");

        if(from_circle && to_circle){
          var path = svg_elt.querySelectorAll('.path');
          if(path) Array.prototype.forEach.call(path, function(e){ e.classList.remove('path') });

          from_txt = from_circle.nextSibling.innerHTML
          to_txt = to_circle.nextSibling.innerHTML

          xhr = new XMLHttpRequest()
          xhr.open('POST', Routes.demo_ratp_path(), true);
          xhr.setRequestHeader('X-CSRF-Token', document.querySelector('meta[name="csrf-token"]').getAttribute('content'));
          xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
          xhr.send("from=" + from_txt + "&to=" + to_txt);

          xhr.onreadystatechange = function(){
            DONE = 4;
            OK = 200;
            if(xhr.readyState == DONE){
              if(xhr.status == OK){
                svg_elt.classList.add('active');
                data = JSON.parse(xhr.responseText);

                Array.prototype.forEach.call(data, function(path){
                  svg_elt.querySelector('circle[data-hash="' + path.node_hash + '"]').classList.add('path');
                  svg_elt.querySelector('text[data-hash="' + path.node_hash + '"]').classList.add('path');
                  if(path.link_hash) svg_elt.querySelector('line[data-hash="' + path.link_hash + '"]').classList.add('path');
                })
              }else{
                svg_elt.classList.remove('active');
                console.log('Error: ' + xhr.status)
              }
            }
          }
        }
      });
    });
  }).call(this)

p class="align-center" <i><small>(clique sur une station de métro pour définir ton point de départ,<br/> puis clique sur une autre pour définir l'arrivée)</small></i>

h3 Sources

p La principale source d'inspiration et d'information pour cet article est un duo de vidéos de la chaîne Youtube "Computerphile" #{":"}

div class='fluid'
  div class='video computer-display'
    iframe src='https://www.youtube.com/embed/GazC3A4OQTE' frameborder='0' allowfullscreen='1'
  p &nbsp;
  div class='video computer-display'
    iframe src='https://www.youtube.com/embed/ySN5Wnu88nE' frameborder='0' allowfullscreen='1'



p Et bien entendu, le site d'open data de la RATP #{":"}

p class='btn-group'
  = link_to "Trafic annuel", "https://data.ratp.fr/explore/dataset/trafic-annuel-entrant-par-station-du-reseau-ferre-2015/table/?disjunctive.reseau&disjunctive.ville&disjunctive.arrondissement_pour_paris&sort=trafic&refine.reseau=M%C3%A9tro", class: :btn, target: :_blank
  = link_to "Positions géographiques", "https://data.ratp.fr/explore/dataset/positions-geographiques-des-stations-du-reseau-ratp/table/?disjunctive.stop_name&disjunctive.code_postal&disjunctive.departement", class: :btn, target: :_blank
  = link_to "Couleurs de lignes", "https://data.ratp.fr/explore/dataset/indices-et-couleurs-de-lignes-du-reseau-ferre-ratp/", class: :btn, target: :_blank
